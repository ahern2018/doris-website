"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["847965"],{944987:function(e,n,i){i.r(n),i.d(n,{metadata:()=>t,contentTitle:()=>d,default:()=>c,assets:()=>o,toc:()=>l,frontMatter:()=>a});var t=JSON.parse('{"id":"table-design/data-model/unique","title":"Primary Key Model","description":"\x3c!--","source":"@site/versioned_docs/version-2.1/table-design/data-model/unique.md","sourceDirName":"table-design/data-model","slug":"/table-design/data-model/unique","permalink":"/docs/table-design/data-model/unique","draft":false,"unlisted":false,"tags":[],"version":"2.1","frontMatter":{"title":"Primary Key Model","language":"en"},"sidebar":"docs","previous":{"title":"Detail Model","permalink":"/docs/table-design/data-model/duplicate"},"next":{"title":"Aggregate Model","permalink":"/docs/table-design/data-model/aggregate"}}'),r=i("785893"),s=i("250065");let a={title:"Primary Key Model",language:"en"},d=void 0,o={},l=[{value:"Use Cases",id:"use-cases",level:2},{value:"Implementation Methods",id:"implementation-methods",level:2},{value:"Merge-on-write",id:"merge-on-write",level:2},{value:"Creating a Merge-on-write Table",id:"creating-a-merge-on-write-table",level:3},{value:"Merge-on-read",id:"merge-on-read",level:2},{value:"Creating a Merge-on-read Table",id:"creating-a-merge-on-read-table",level:3},{value:"Data Insertion and Storage",id:"data-insertion-and-storage",level:2},{value:"Notes",id:"notes",level:2}];function u(e){let n={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["When data updates are required, you can choose to use the ",(0,r.jsx)(n.strong,{children:"Unique Key Model"}),". The Unique Key Model ensures the uniqueness of the Key columns. When users insert or update data, the newly written data will overwrite the old data with the same Key columns, thus maintaining the most up-to-date records. Compared to other data models, the Unique Key Model is suitable for data update scenarios, allowing updates and overwrites at the primary key level during the insertion process."]}),"\n",(0,r.jsx)(n.p,{children:"The Unique Key Model has the following characteristics:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"UPSERT based on Primary Key"}),": When inserting data, records with duplicate primary keys are updated, while records without a primary key are inserted."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Deduplication based on Primary Key"}),": The Key columns in the Unique Key Model are unique, and data is deduplicated based on the primary key columns."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Supports High-frequency Data Updates"}),": It supports high-frequency data update scenarios while balancing the performance of data updates and query performance."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"High-frequency Data Updates"}),": In upstream OLTP databases, where dimension tables are frequently updated, the primary key model can efficiently synchronize the upstream updated records and perform efficient UPSERT operations."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Efficient Data Deduplication"}),": In scenarios such as advertising campaigns or customer relationship management systems, where deduplication is required based on user IDs, the primary key model ensures efficient deduplication."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Partial Record Updates"}),": In some business scenarios, only certain columns need to be updated, such as in user profiling where dynamic tags change frequently, or in order consumption scenarios where the transaction status needs to be updated. The primary key model's partial column update capability allows for changes to specific columns."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"implementation-methods",children:"Implementation Methods"}),"\n",(0,r.jsx)(n.p,{children:"In Doris, the Unique Key Model has two implementation methods:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Merge-on-write"}),": Starting from version 1.2, the default implementation of the Unique Key Model in Doris is the merge-on-write mode. In this mode, data is immediately merged for the same Key upon writing, ensuring that the data storage state after each write is the final merged result of the unique key, and only the latest result is stored. Merge-on-write provides a good balance between query and write performance, avoiding the need to merge multiple versions of data during queries and ensuring predicate pushdown to the storage layer. The merge-on-write model is recommended for most scenarios."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Merge-on-read"}),": Prior to version 1.2, Doris's Unique Key Model defaulted to merge-on-read mode. In this mode, data is not merged upon writing but is appended incrementally, retaining multiple versions within Doris. During queries or Compaction, data is merged by the same Key version. Merge-on-read is suitable for write-heavy and read-light scenarios, but during queries, multiple versions must be merged, and predicates cannot be pushed down, which may affect query speed."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"In Doris, there are two types of update semantics for the Unique Key Model:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The default update semantic for the Unique Key Model is ",(0,r.jsx)(n.strong,{children:"full row UPSERT"}),", i.e., UPDATE OR INSERT. If the Key of the row exists, it will be updated; if it does not exist, new data will be inserted. In the full row UPSERT semantic, even if the user inserts data into specific columns using ",(0,r.jsx)(n.code,{children:"INSERT INTO"}),", Doris will fill in the missing columns with NULL values or default values during the planner stage."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Partial column updates"}),". If users want to update specific fields, they need to use the merge-on-write implementation and enable partial column updates support via specific parameters. Please refer to the documentation on ",(0,r.jsx)(n.a,{href:"../../data-operate/update/update-of-unique-model",children:"Partial Column Updates"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"merge-on-write",children:"Merge-on-write"}),"\n",(0,r.jsx)(n.h3,{id:"creating-a-merge-on-write-table",children:"Creating a Merge-on-write Table"}),"\n",(0,r.jsxs)(n.p,{children:["When creating a table, the ",(0,r.jsx)(n.strong,{children:"UNIQUE KEY"})," keyword can be used to specify a Unique Key table. The merge-on-write mode can be enabled by explicitly setting the ",(0,r.jsx)(n.code,{children:"enable_unique_key_merge_on_write"})," attribute. Since Doris version 2.1, the merge-on-write mode is enabled by default:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE IF NOT EXISTS example_tbl_unique\n(\n    user_id         LARGEINT        NOT NULL,\n    user_name       VARCHAR(50)     NOT NULL,\n    city            VARCHAR(20),\n    age             SMALLINT,\n    sex             TINYINT\n)\nUNIQUE KEY(user_id, user_name)\nDISTRIBUTED BY HASH(user_id) BUCKETS 10\nPROPERTIES (\n    "enable_unique_key_merge_on_write" = "true"\n);\n'})}),"\n",(0,r.jsx)(n.h2,{id:"merge-on-read",children:"Merge-on-read"}),"\n",(0,r.jsx)(n.h3,{id:"creating-a-merge-on-read-table",children:"Creating a Merge-on-read Table"}),"\n",(0,r.jsxs)(n.p,{children:["When creating a table, the ",(0,r.jsx)(n.strong,{children:"UNIQUE KEY"})," keyword can be used to specify a Unique Key table. The merge-on-read mode can be enabled by explicitly disabling the ",(0,r.jsx)(n.code,{children:"enable_unique_key_merge_on_write"})," attribute. Before Doris version 2.1, the merge-on-read mode was enabled by default:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE IF NOT EXISTS example_tbl_unique\n(\n    user_id         LARGEINT        NOT NULL,\n    username        VARCHAR(50)     NOT NULL,\n    city            VARCHAR(20),\n    age             SMALLINT,\n    sex             TINYINT\n)\nUNIQUE KEY(user_id, username)\nDISTRIBUTED BY HASH(user_id) BUCKETS 10\nPROPERTIES (\n    "enable_unique_key_merge_on_write" = "false"\n);\n'})}),"\n",(0,r.jsx)(n.h2,{id:"data-insertion-and-storage",children:"Data Insertion and Storage"}),"\n",(0,r.jsx)(n.p,{children:"In a Unique Key table, the Key column is not only used for sorting but also for deduplication. After data insertion, new data will overwrite records with the same Key value."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"unique-key-model-insert",src:i(598390).Z+"",width:"5188",height:"2596"})}),"\n",(0,r.jsx)(n.p,{children:"As shown in the example, there were 4 rows of data in the original table. After inserting 2 new rows, the newly inserted rows are updated based on the primary key:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"-- insert into raw data\nINSERT INTO example_tbl_unique VALUES\n(101, 'Tom', 'BJ', 26, 1),\n(102, 'Jason', 'BJ', 27, 1),\n(103, 'Juice', 'SH', 20, 2),\n(104, 'Olivia', 'SZ', 22, 2);\n\n-- insert into data to update by key\nINSERT INTO example_tbl_unique VALUES\n(101, 'Tom', 'BJ', 27, 1),\n(102, 'Jason', 'SH', 28, 1);\n\n-- check updated data\nSELECT * FROM example_tbl_unique;\n+---------+----------+------+------+------+\n| user_id | username | city | age  | sex  |\n+---------+----------+------+------+------+\n| 101     | Tom      | BJ   |   27 |    1 |\n| 102     | Jason    | SH   |   28 |    1 |\n| 104     | Olivia   | SZ   |   22 |    2 |\n| 103     | Juice    | SH   |   20 |    2 |\n+---------+----------+------+------+------+\n"})}),"\n",(0,r.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["It is recommended to use the merge-on-write mode after Doris 1.2.4. In version 1.2, enabling merge-on-write requires adding the configuration ",(0,r.jsx)(n.code,{children:"disable_storage_page_cache=false"})," in the ",(0,r.jsx)(n.code,{children:"be.conf"})," file. Not enabling this option may significantly impact import performance. This feature is enabled by default in version 2.0 and later."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The implementation method for Unique tables can only be determined during table creation and cannot be changed through schema changes."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["In the full row ",(0,r.jsx)(n.code,{children:"UPSERT"})," semantic, even if users insert into specific columns using ",(0,r.jsx)(n.code,{children:"INSERT INTO"}),", Doris will fill in the missing columns with NULL values or default values during the planner stage."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Partial column updates"}),": If users want to update specific fields, they need to use the merge-on-write implementation and enable partial column updates via specific parameters. Please refer to the documentation on ",(0,r.jsx)(n.a,{href:"../../data-operate/update/update-of-unique-model",children:"Partial Column Updates"})," for related usage suggestions."]}),"\n"]}),"\n"]})]})}function c(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},598390:function(e,n,i){i.d(n,{Z:function(){return t}});let t=i.p+"assets/images/unique-key-model-insert-9efad210cd22c8c80098b55f0a4f5d8f.png"},250065:function(e,n,i){i.d(n,{Z:function(){return d},a:function(){return a}});var t=i(667294);let r={},s=t.createContext(r);function a(e){let n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);